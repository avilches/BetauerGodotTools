using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Betauer.Core.Collision;
using Betauer.Core.PoissonDiskSampling.Utils;
using Godot;

namespace Betauer.Core.PoissonDiskSampling; 

public class PoissonSampler2D {
    /// <summary>
    /// The point generated by the poisson sampler in the las Generate() call.
    /// </summary>
    public List<Vector2> Samples { get; protected set; }

    /// <summary>
    /// The width of the domain of the sampler. This is the maximum <c>x</c> value in a generated point.
    /// </summary>
    public float Width { get; protected set; }

    /// <summary>
    /// The height of the domain of the sampler. This is the maximum <c>y</c> value in a generated point.
    /// </summary>
    public float Height { get; protected set; }

    /// <summary>
    /// The maximum number of attempts to generate a valid new point.
    /// The higher this value, the higher the coverage of the sampler but an increased runtime cost.
    /// </summary>
    public int RejectionLimit { get; }

    public PoissonSampler2D(float width, float height, int rejectionLimit) {
        Width = width;
        Height = height;
        RejectionLimit = rejectionLimit;
    }

    
    /// <summary>
    /// Generate a new random point in the annulus around the provided point.
    /// </summary>
    /// <param name="point"></param>
    /// <returns></returns>
    public static Vector2 GenerateRandomPointInAnnulus(Random random, ref Vector2 point, float radius) {
        var min = radius;
        var max = radius * 2.0f;
        var distance = ((float)random.NextDouble() * (max - min)) + min;
        var angle = (float)random.NextDouble() * Mathf.Tau;
        return new Vector2(
            point.X + (float)Math.Cos(angle) * distance,
            point.Y + (float)Math.Sin(angle) * distance);
    }
}