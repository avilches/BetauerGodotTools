using System;
using System.Collections.Generic;

namespace Betauer.Core.PoissonDiskSampling; 

/*
 * https://www.vertexfragment.com/ramblings/variable-density-poisson-sampler/
 */
/// <summary>
/// A poisson sampler that operates on any dimension.
/// Unlike the other implementations, this one is intended to use only standard C# libraries for ease of portability.
/// </summary>
public sealed class UniformPoissonSamplerND {
    /// <summary>
    /// The sample point generated by the sampler.
    /// </summary>
    public List<float[]> Samples { get; private set; }

    /// <summary>
    /// 
    /// </summary>
    public float[] GridDimensions { get; }

    /// <summary>
    /// The radius of the sample points, aka the minimum distance between points. 
    /// No two sampled points can be any closer than this value, but may be further away.
    /// </summary>
    public float Radius { get; }

    /// <summary>
    /// The maximum number of attempts to generate a valid new point.
    /// The higher this value, the higher the coverage of the sampler but an increased runtime cost.
    /// </summary>
    public int RejectionLimit { get; }

    /// <summary>
    /// The RNG used to generate the points in the sampled annulus.
    /// </summary>
    private readonly Random _random;

    /// <summary>
    /// 
    /// </summary>
    private readonly int _spatialDimensions;

    // ---------------------------------------------------------------------------------
    // Spatial Grid Properties
    // ---------------------------------------------------------------------------------

    // Note that we implement our own Spatial Grid here and do not use SpatialGrid2D.
    // This is because we know there is a fixed radius and exactly one point per cell and so we are able
    // to take some short cuts for better performance that is not available in the more generic SpatialGrid2D.

    /// <summary>
    /// The length of each side of a cell in the underlying spatial grid.
    /// </summary>
    private float _cellLength;

    /// <summary>
    /// 
    /// </summary>
    private int[] _cellsPerDimension;

    /// <summary>
    /// The spatial grid used at as a lookup for faster "are there any nearby points?" queries.
    /// Stored as a 1D array, and accessed via <see cref="GetSpatialGridIndex(ref Vector2)"/>.
    /// </summary>
    private List<int> _spatialLookUp;

    /// <summary>
    /// List of candidate points that we will try to generate new points around.
    /// </summary>
    private List<int> _activeList;

    // ---------------------------------------------------------------------------------
    // Methods
    // ---------------------------------------------------------------------------------

    public UniformPoissonSamplerND(Random random, float sampleRadius, float[] dimensions, int rejectionLimit = 30) {
        _random = random;
        Radius = sampleRadius;
        GridDimensions = dimensions;
        RejectionLimit = rejectionLimit;
        _spatialDimensions = dimensions.Length;
    }

    public List<float[]> Generate() {
        Initialize();
        GenerateFirstPoint();

        while (_activeList.Count > 0) {
            var sampleFound = false;
            var activeIndex = GetRandomActiveListIndex();
            var sample = Samples[_activeList[activeIndex]];

            for (var i = 0; i < RejectionLimit; ++i) {
                var randomSample = GenerateRandomPointInAnnulus(sample);

                if (!IsSampleOutOfBounds(randomSample) && !IsSampleNearOthers(randomSample)) {
                    AddSample(randomSample);
                    sampleFound = true;
                    break;
                }
            }

            if (!sampleFound) {
                _activeList[activeIndex] = _activeList[_activeList.Count - 1];
                _activeList.RemoveAt(_activeList.Count - 1);
            }
        }
        return Samples;
    }

    /// <summary>
    /// Initializes the sampler for a new run.
    /// </summary>
    private void Initialize() {
        _cellLength = Radius / (float)Math.Sqrt(_spatialDimensions);
        _cellsPerDimension = new int[_spatialDimensions];

        int totalCells = 1;

        for (int i = 0; i < _spatialDimensions; ++i) {
            _cellsPerDimension[i] = (int)Math.Ceiling(GridDimensions[i] / _cellLength);
            totalCells *= _cellsPerDimension[i];
        }

        _spatialLookUp = new List<int>(totalCells);
        _activeList = new List<int>(totalCells);
        Samples = new List<float[]>();

        for (int i = 0; i < totalCells; ++i) {
            _spatialLookUp.Add(-1);
        }
    }

    /// <summary>
    /// Generates the first random point in the sample domain and adds it to our collections.
    /// </summary>
    private void GenerateFirstPoint() {
        float[] point = new float[_spatialDimensions];

        for (int i = 0; i < _spatialDimensions; ++i) {
            point[i] = (float)_random.NextDouble() * GridDimensions[i];
        }

        AddSample(point);
    }

    /// <summary>
    /// Adds the new sample to the samples list, active list, and spatial grid.
    /// </summary>
    /// <param name="sample"></param>
    private void AddSample(float[] sample) {
        int sampleIndex = Samples.Count;
        int spatialIndex = GetSpatialGridIndex(sample);

        Samples.Add(sample);
        _activeList.Add(sampleIndex);
        _spatialLookUp[spatialIndex] = sampleIndex;
    }

    /// <summary>
    /// Calculates the index into the spatial grid for the given point.
    /// Does not perform bounds checking.
    /// </summary>
    /// <param name="point"></param>
    /// <returns></returns>
    private int GetSpatialGridIndex(float[] point) {
        int[] cells = new int[_spatialDimensions];

        for (int i = 0; i < _spatialDimensions; ++i) {
            if ((point[i] < 0.0f) || (point[i] > GridDimensions[i])) {
                return -1;
            }

            cells[i] = (int)(point[i] / _cellLength);
        }

        return GetSpatialGridIndex(cells);
    }

    /// <summary>
    /// Calculates the 1D array index for the ND cell indices.
    /// </summary>
    /// <param name="cells"></param>
    /// <returns></returns>
    private int GetSpatialGridIndex(int[] cells) {
        int index = 0;

        if (cells[_spatialDimensions - 1] >= 0) {
            index = cells[_spatialDimensions - 1];

            if (index >= _cellsPerDimension[_spatialDimensions - 1]) {
                index = _cellsPerDimension[_spatialDimensions - 1] - 1;
            }
        }

        for (int i = (_spatialDimensions - 1); i > 0; --i) {
            index *= _cellsPerDimension[i - 1];

            if (cells[i - 1] >= 0) {
                int j = cells[i - 1];

                if (j >= _cellsPerDimension[i - 1]) {
                    j = _cellsPerDimension[i - 1] - 1;
                }

                index += j;
            }
        }

        return index;
    }

    /// <summary>
    /// Retrieves a random index from the active list.
    /// </summary>
    /// <returns></returns>
    private int GetRandomActiveListIndex() {
        return _random.Next(_activeList.Count);
    }

    /// <summary>
    /// Generate a new random point in the annulus around the provided point.
    /// </summary>
    /// <param name="point"></param>
    /// <returns></returns>
    private float[] GenerateRandomPointInAnnulus(float[] point) {
        float[] randomVector = GetRandomUnitVectorOnHypersphere(_random, _spatialDimensions);
        float randomDistance = Lerp(Radius, Radius * 2.0f, (float)_random.NextDouble());
        float[] newSamplePoint = new float[_spatialDimensions];

        for (int i = 0; i < _spatialDimensions; ++i) {
            newSamplePoint[i] = point[i] + randomVector[i] * randomDistance;
        }

        return newSamplePoint;
    }

    /// <summary>
    /// Is the point within bounds of the sample domain?
    /// </summary>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleOutOfBounds(float[] sample) {
        for (int i = 0; i < _spatialDimensions; ++i) {
            if ((sample[i] < 0.0f) || (sample[i] > GridDimensions[i])) {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the sample is near any others by checking neighboring cells.
    /// </summary>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleNearOthers(float[] sample) {
        int prospectiveCell = GetSpatialGridIndex(sample);

        if ((prospectiveCell == -1) || _spatialLookUp[prospectiveCell] != -1) {
            return true;
        }

        // Find the min and max corners of the hypercube we will be searching for intersections in.
        int[] minCell = new int[_spatialDimensions];
        int[] maxCell = new int[_spatialDimensions];

        for (int i = 0; i < _spatialDimensions; ++i) {
            float localMin = Clamp(sample[i] - Radius, 0, GridDimensions[i]);
            float localMax = Clamp(sample[i] + Radius, 0, GridDimensions[i]);

            minCell[i] = (int)(localMin / _cellLength);
            maxCell[i] = (int)(localMax / _cellLength);
        }

        // Traverse each neighbor and check if there are any intersections.
        int[] current = CopyArray(minCell);

        while (true) {
            // This loop is so weird, I know. I tried refactoring the one in the original C++ source to something a bit more normal, but well here we are.
            // Essentially we start at one "corner" of our hypercube (minCell) and iterate ourselves along all n-dimensions until we reach the opposite corner (maxCell).
            int localCell = GetSpatialGridIndex(current);

            if (IsSampleNearSampleInCell(localCell, sample)) {
                return true;
            }

            for (int i = 0; i <= _spatialDimensions; ++i) {
                current[i]++;

                if (current[i] <= maxCell[i]) {
                    break;
                } else {
                    if (i == (_spatialDimensions - 1)) {
                        return false;
                    } else {
                        current[i] = minCell[i];
                    }
                }
            }
        }
    }

    /// <summary>
    /// Checks if the provided sample is near any others in the specified cell.
    /// </summary>
    /// <param name="lookupCell"></param>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleNearSampleInCell(int lookupCell, float[] sample) {
        if ((lookupCell < 0) || (lookupCell >= _spatialLookUp.Count)) {
            return false;
        }

        int cellSampleIndex = _spatialLookUp[lookupCell];

        if (cellSampleIndex == -1) {
            return false;
        }

        return SquaredDistanceBetween(sample, Samples[cellSampleIndex]) <= (Radius * Radius);
    }

    /// <summary>
    /// Returns the squared distance between the two n-dimensional vectors.
    /// </summary>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <returns></returns>
    private float SquaredDistanceBetween(float[] a, float[] b) {
        float squaredDistance = 0.0f;

        for (int i = 0; i < _spatialDimensions; ++i) {
            float delta = b[i] - a[i];
            squaredDistance += delta * delta;
        }

        return squaredDistance;
    }

    /// <summary>
    /// Clamps the value.
    /// </summary>
    /// <param name="x"></param>
    /// <param name="min"></param>
    /// <param name="max"></param>
    /// <returns></returns>
    private static float Clamp(float x, float min, float max) {
        return (x < min ? min : x > max ? max : x);
    }

    /// <summary>
    /// Returns a unit n-dimensional vector.
    /// </summary>
    /// <param name="rng"></param>
    /// <param name="dimensions"></param>
    /// <returns></returns>
    private static float[] GetRandomUnitVectorOnHypersphere(Random rng, int dimensions) {
        float[] randomUnitVector = new float[dimensions];

        for (int i = 0; i < dimensions; ++i) {
            randomUnitVector[i] = ((float)rng.NextDouble() * 2.0f) - 1.0f; // Transform from [0, 1] to [-1, 1]
        }

        float vectorMagnitude = 0.0f;

        for (int i = 0; i < dimensions; ++i) {
            vectorMagnitude += randomUnitVector[i] * randomUnitVector[i];
        }

        float squaredMagnitude = (float)Math.Sqrt(vectorMagnitude);

        for (int i = 0; i < dimensions; ++i) {
            randomUnitVector[i] /= squaredMagnitude;
        }

        return randomUnitVector;
    }

    /// <summary>
    /// Standard linear interpolation.
    /// </summary>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <param name="frac"></param>
    /// <returns></returns>
    private static float Lerp(float a, float b, float frac) {
        return (a * (1.0f - frac) + (b * frac));
    }

    /// <summary>
    /// Copies the contents of the source array into a new array.
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    private static T[] CopyArray<T>(T[] source) {
        T[] copy = new T[source.Length];

        for (int i = 0; i < source.Length; ++i) {
            copy[i] = source[i];
        }

        return copy;
    }
}