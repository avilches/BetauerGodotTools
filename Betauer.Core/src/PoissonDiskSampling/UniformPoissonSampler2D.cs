using System;
using System.Collections.Generic;
using Betauer.Core.PoissonDiskSampling.Utils;
using Godot;

namespace Betauer.Core.PoissonDiskSampling; 

/*
 * https://www.vertexfragment.com/ramblings/variable-density-poisson-sampler/
 */
/// <summary>
/// A poisson disk sampler (blue noise) where the sample radius (minimum distance between points) is constant/uniform through the entire domain.
/// </summary>
public sealed class UniformPoissonSampler2D {
    /// <summary>
    /// The sample point generated by the sampler.
    /// </summary>
    public List<Vector2> Samples { get; private set; }

    /// <summary>
    /// The width of the domain of the sampler. This is the maximum <c>x</c> value in a generated point.
    /// </summary>
    public float Width { get; }

    /// <summary>
    /// The height of the domain of the sampler. This is the maximum <c>y</c> value in a generated point.
    /// </summary>
    public float Height { get; }

    /// <summary>
    /// The radius of the sample points, aka the minimum distance between points. 
    /// No two sampled points can be any closer than this value, but may be further away.
    /// </summary>
    public float SampleRadius { get; }

    /// <summary>
    /// The maximum number of attempts to generate a valid new point.
    /// The higher this value, the higher the coverage of the sampler but an increased runtime cost.
    /// </summary>
    public int RejectionLimit { get; }

    /// <summary>
    /// The RNG used to generate the points in the sampled annulus.
    /// </summary>
    private readonly Random _random;

    // ---------------------------------------------------------------------------------
    // Spatial Grid Properties
    // ---------------------------------------------------------------------------------

    // Note that we implement our own Spatial Grid here and do not use SpatialGrid2D.
    // This is because we know there is a fixed radius and exactly one point per cell and so we are able
    // to take some short cuts for better performance that is not available in the more generic SpatialGrid2D.

    /// <summary>
    /// The length of each side of a cell in the underlying spatial grid.
    /// </summary>
    private float _cellLength;

    /// <summary>
    /// The number of cells in the x-dimension in the underlying spatial grid.
    /// </summary>
    private int _cellsPerX;

    /// <summary>
    /// The number of cells in the y-dimension in the underlying spatial grid.
    /// </summary>
    private int _cellsPerY;

    /// <summary>
    /// The spatial grid used at as a lookup for faster "are there any nearby points?" queries.
    /// Stored as a 1D array, and accessed via <see cref="GetSpatialGridIndex(ref Vector2)"/>.
    /// </summary>
    private List<int> _spatialLookUp;

    /// <summary>
    /// List of candidate points that we will try to generate new points around.
    /// </summary>
    private List<int> _activeList;

    // ---------------------------------------------------------------------------------
    // Methods
    // ---------------------------------------------------------------------------------

    /// <param name="random">The RNG used to generate the random points.</param>
    /// <param name="sampleRadius">The minimum distance between points.</param>
    /// <param name="width">The width of the sampler domain. The maximum x value of a sampled position will be this.</param>
    /// <param name="height">The height of the sampler domain. The maximum y value of a sampled position will be this.</param>
    /// <param name="rejectionLimit">Number of generation attempts before a prospective point is rejected.</param>
    public UniformPoissonSampler2D(Random random, float sampleRadius, float width, float height, int rejectionLimit = 30) {
        _random = random;
        SampleRadius = sampleRadius;
        Width = width;
        Height = height;
        RejectionLimit = rejectionLimit;
    }

    /// <summary>
    /// Fills the sample domain with blue noise distributed points.
    /// Once generation is complete the results can be obtained from <see cref="Samples"/>.
    /// </summary>
    /// <returns></returns>
    public List<Vector2> Generate() {
        Initialize();
        GenerateFirstPoint();

        while (_activeList.Count > 0) {
            var sampleFound = false;
            var activeIndex = GetRandomActiveListIndex();
            Vector2 currentSample = Samples[_activeList[activeIndex]];

            for (var i = 0; i < RejectionLimit; ++i) {
                Vector2 randomSample = GenerateRandomPointInAnnulus(ref currentSample);

                if (!IsSampleOutOfBounds(ref randomSample) && !IsSampleNearOthers(ref randomSample)) {
                    AddSample(ref randomSample);
                    sampleFound = true;
                    break;
                }
            }
            if (!sampleFound) {
                _activeList.RemoveUnorderedAt(activeIndex);
            }
        }

        return Samples;
    }
        
    /// <summary>
    /// Initializes the sampler for a new run.
    /// </summary>
    private void Initialize() {
        _cellLength = SampleRadius / Mathf.Sqrt2;
        _cellsPerX = (int)Math.Ceiling(Width / _cellLength);
        _cellsPerY = (int)Math.Ceiling(Height / _cellLength);

        var totalCells = _cellsPerX * _cellsPerY;

        _spatialLookUp = new List<int>(totalCells);
        _activeList = new List<int>(totalCells);
        Samples = new List<Vector2>();

        for (int i = 0; i < totalCells; ++i) {
            _spatialLookUp.Add(-1);
        }
    }

    /// <summary>
    /// Generates the first random point in the sample domain and adds it to our collections.
    /// </summary>
    private void GenerateFirstPoint() {
        Vector2 sample = new Vector2(
            (float)_random.NextDouble() * Width,
            (float)_random.NextDouble() * Height);

        AddSample(ref sample);
    }

    /// <summary>
    /// Adds the new sample to the samples list, active list, and spatial grid.
    /// </summary>
    /// <param name="sample"></param>
    private void AddSample(ref Vector2 sample) {
        int sampleIndex = Samples.Count;
        int spatialIndex = GetSpatialGridIndex(ref sample);

        Samples.Add(sample);
        _activeList.Add(sampleIndex);
        _spatialLookUp[spatialIndex] = sampleIndex;
    }

    /// <summary>
    /// Calculates the index into the spatial grid for the given point.
    /// Does not perform bounds checking.
    /// </summary>
    /// <param name="sample"></param>
    /// <returns></returns>
    private int GetSpatialGridIndex(ref Vector2 sample) {
        int dx = (int)(sample.X / _cellLength);
        int dy = (int)(sample.Y / _cellLength);

        return (dx + (dy * _cellsPerX));
    }

    /// <summary>
    /// Retrieves a random index from the active list.
    /// </summary>
    /// <returns></returns>
    private int GetRandomActiveListIndex() {
        return _random.Next(_activeList.Count);
    }

    /// <summary>
    /// Generate a new random point in the annulus around the provided point.
    /// </summary>
    /// <param name="point"></param>
    /// <returns></returns>
    private Vector2 GenerateRandomPointInAnnulus(ref Vector2 point) {
        float min = SampleRadius;
        float max = SampleRadius * 2.0f;

        float distance = ((float)_random.NextDouble() * (max - min)) + min;
        float angle = (float)_random.NextDouble() * Mathf.Tau;

        return new Vector2(
            point.X + ((float)Math.Cos(angle) * distance),
            point.Y + ((float)Math.Sin(angle) * distance));
    }

    /// <summary>
    /// Is the point within bounds of the sample domain?
    /// </summary>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleOutOfBounds(ref Vector2 sample) {
        return (sample.X < 0.0f) || (sample.X > Width) || (sample.Y < 0.0f) || (sample.Y > Height);
    }

    /// <summary>
    /// Checks if the sample is near any others by checking neighboring cells.
    /// </summary>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleNearOthers(ref Vector2 sample) {
        int prospectiveCell = GetSpatialGridIndex(ref sample);

        if ((prospectiveCell == -1) || _spatialLookUp[prospectiveCell] != -1) {
            return true;
        }

        for (int y = -1; y <= 1; ++y) {
            for (int x = -1; x <= 1; ++x) {
                int neighbor = prospectiveCell + x + (y * _cellsPerX);

                if (IsSampleNearSampleInCell(neighbor, ref sample)) {
                    return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the provided sample is near any others in the specified cell.
    /// </summary>
    /// <param name="lookupCell"></param>
    /// <param name="sample"></param>
    /// <returns></returns>
    private bool IsSampleNearSampleInCell(int lookupCell, ref Vector2 sample) {
        if ((lookupCell < 0) || (lookupCell >= _spatialLookUp.Count)) {
            return false;
        }

        int cellSampleIndex = _spatialLookUp[lookupCell];

        if (cellSampleIndex == -1) {
            return false;
        }

        return sample.DistanceTo(Samples[cellSampleIndex]) <= SampleRadius;
    }
}